#!/bin/python3

# This script outputs the current display layout to a script which for example,
# enables the user to quickly switch between layouts using scripts
# You can for example use the "wdisplays" program to configure your layout and then use this script to save the layout to a script

import subprocess
from argparse import ArgumentParser
import json
import math
from typing import List, Dict

def run(args):
    # print("Running: " + args)
    return subprocess.run(args, shell=True, capture_output=True).stdout.decode("ascii")

def divide_chunks(list: list[int], count: int):
    for i in range(0, len(list), count):
        yield list[i:i + count]

# global, ugly, but w/e, good enough
sway_outputs = json.loads(run("swaymsg --raw -t get_outputs"))

def get_monitor_names() -> List[str]:
    monitor_names = []
    for monitor in sway_outputs:
        monitor_names.append(monitor["name"])
    return monitor_names

def list_monitors():
    print("Use the number of your desired primary monitor as argument to the --generate command\n")
    counter = 1
    for monitor in sway_outputs:
        print("{}: {} ({})".format(counter, monitor["name"], monitor["model"]))
        counter += 1


def get_workspaces_divided_per_monitor(monitor_names: List[str]) -> List[List[int]]:
    workspaces = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    chunk_size = math.floor(len(workspaces) / len(monitor_names))

    # Check if our workspaces are evenly distributable on our monitors
    if len(workspaces) % len(monitor_names) == 0:
        return list(divide_chunks(workspaces, chunk_size))
    else:
        monitor_desktop_chunks: List[List[int]] = []
        remains = len(workspaces) % len(monitor_names)
        is_first_monitor_handled = False
        next = 0
        for i in range(0, chunk_size):
            if not is_first_monitor_handled:
                next = chunk_size + remains
                monitor_desktop_chunks.insert(i, workspaces[i:next])
                is_first_monitor_handled = True
            else:
                monitor_desktop_chunks.insert(i, workspaces[next:next + chunk_size])
                next = next + chunk_size

        return monitor_desktop_chunks

def generate(primary_monitor_number: int):
    monitor_names = get_monitor_names()
    primary_monitor = monitor_names[primary_monitor_number - 1]
    # Rearrange monitors in list so that our primary monitor gets the first chunk of the workspaces
    monitor_names.remove(primary_monitor)
    monitor_names.insert(0, primary_monitor)

    monitor_commands: List[str] = []
    waybar_monitor_config: List[str] = []
    monitor_variables_map: Dict[str, str] = {}

    monitor_desktop_chunks = get_workspaces_divided_per_monitor(monitor_names)
    current_chunk_counter = 0
    for monitor_name in monitor_names:

        monitor_assigned_chunk = monitor_desktop_chunks[current_chunk_counter]
        monitor_variables_map[monitor_name] = "MON_{}".format(current_chunk_counter)

        for workspace in monitor_assigned_chunk:
            if workspace == " ":
                continue
            current_mon = f"$MON_{current_chunk_counter}"
            monitor_commands.append(f"swaymsg \"workspace {workspace} output {current_mon}; workspace number {workspace}; move workspace to {current_mon}\"")
            waybar_monitor_config.append('"{}": ["{}"],'.format(workspace, current_mon))

        current_chunk_counter = current_chunk_counter + 1

    # add some line breaks to script
    monitor_commands.append("")

    for monitor in sway_outputs:
        if not monitor["active"]:
            monitor_commands.append("swaymsg output {} disable".format(monitor["name"]))
        else:

            command = [
                "swaymsg output ${}".format(monitor_variables_map[monitor["name"]]),
                "res {}x{}@{}hz".format(
                    monitor["current_mode"]["width"],
                    monitor["current_mode"]["height"],
                    monitor["current_mode"]["refresh"] / 1000,
                ),
                "scale {}".format(monitor["scale"]),
                "transform {}".format(monitor["transform"]),
                "pos {} {}".format(monitor["rect"]["x"], monitor["rect"]["y"]),
                "enable"
            ]
            monitor_commands.append(" ".join(command))

    print("#!/bin/bash\n")
    for monitor_name, variable_name in monitor_variables_map.items():
        if monitor_name is primary_monitor:
            print("{}={} #This is your 'primary' monitor".format(variable_name, monitor_name))
        else:
            print("{}={}".format(variable_name, monitor_name))
    print("")
    for command in monitor_commands:
        print(command)
    print("")
    # generate persistent workspaces for waybar so that the assigned workspaces are shown in the bar of the individual monitors
    print("waybar_persistent_workspaces=$(cat << EOF\n{")
    for command in waybar_monitor_config:
        print(command)
    print("}\nEOF\n)")

    print("# This jq command replaces the JSON key's value with our own")
    print('jq \'."sway\/workspaces".persistent_workspaces = \'"$waybar_persistent_workspaces" \\\n\t~/.config/waybar/config_base > ~/.config/waybar/config')

    # TODO
    #  for monitor_name, variable_name in monitor_variables_map.items():
        #  # configure main monitors bar
        #  if monitor_name is primary_monitor:
            #  print('jq \'.["output"] += ["\'${}\'"]\' \\\n\t~/.config/waybar/config_base > ~/.config/waybar/config'.format(variable_name))
        #  #  configure non-main monitor bars
        #  if monitor_name is primary_monitor:
            #  print('jq \'.["output"] += ["\'${}\'"]\' \\\n\t~/.config/waybar/config_base > ~/.config/waybar/config'.format(variable_name))
    # NOTE
    # I'm keeping this around in case I switch to some other bar than Waybar
    #
    # print("")
    # print("#Spawn a terminal on all the workspaces which are not the 1st workspace on a given monitor")
    # print("#This is to keep them visible on the statusbar because Sway destroys the workspaces if they're empty")
    # print("#This is a little hacky but is a statusbar independent solution")
    # print("used_workspaces=($(swaymsg -t get_workspaces -r | jq -r '[.[].name] | @sh'))")
    # for chunk in monitor_desktop_chunks:
    # firstWorkspaceIterated = False
    # for workspaceNumber in chunk:
    # if firstWorkspaceIterated == False:
    # firstWorkspaceIterated = True
    # continue
    # print('if [[ ! " ${used_workspaces[@]} " =~ "' + "{}".format(workspaceNumber) + '" ]]; then')
    # print("\tswaymsg 'workspace number {}; exec alacritty'".format(workspaceNumber))
    # print("fi")
    # print("sleep 0.1")

    # print("\n#this ensures that workspace 1 is placed on our monitor of choice")
    # print('swaymsg \'move workspace to output {}\''.format(primary_monitor))
    # print("swaymsg 'workspace number 1'")

parser = ArgumentParser()
parser.add_argument("-l", "--list", action="store_true", help="List monitors to pick as primary monitor")
parser.add_argument("-g", "--generate", metavar="monitor number", dest="generate", type=int, help="Pick primary monitor and the layout will be generated")

args = parser.parse_args()
if args.list:
    list_monitors()
    exit(0)
if args.generate is not None:
    generate(args.generate)
    exit(0)

# no option was chosen, print helpful info
parser.print_help()
